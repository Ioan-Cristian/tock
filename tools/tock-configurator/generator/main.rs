//! GENERATED BY TOCKOS CONFIGURATOR.
#![no_std]
#![cfg_attr(not(doc), no_main)]
use kernel::component::Component;
use kernel::platform::{KernelResources, SyscallDriverLookup};
pub mod io;
mod otbn;
pub mod pinmux_layout;
#[cfg(test)]
mod tests;
/// The `earlgrey` chip crate supports multiple targets with slightly different
/// configurations, which are encoded through implementations of the
/// `earlgrey::chip_config::EarlGreyConfig` trait. This type provides different
/// implementations of the `EarlGreyConfig` trait, depending on Cargo's
/// conditional compilation feature flags. If no feature is selected,
/// compilation will error.
pub enum ChipConfig {}
#[cfg(feature = "fpga_cw310")]
impl earlgrey::chip_config::EarlGreyConfig for ChipConfig {
    const NAME: &'static str = "fpga_cw310";
    const CPU_FREQ: u32 = 24_000_000;
    const PERIPHERAL_FREQ: u32 = 6_000_000;
    const AON_TIMER_FREQ: u32 = 250_000;
    const UART_BAUDRATE: u32 = 115200;
}
pub const EPMP_HANDOVER_CONFIG_CHECK: bool = false;
pub const NUM_PROCS: usize = 0usize;
const FAULT_RESPONSE: capsules_system::process_policies::PanicFaultPolicy = capsules_system::process_policies::PanicFaultPolicy {};
static mut PROCESSES: [Option<&'static dyn kernel::process::Process>; NUM_PROCS] = [None; NUM_PROCS];
static mut PROCESS_PRINTER: Option<
    &'static capsules_system::process_printer::ProcessPrinterText,
> = None;
static mut CHIP: Option<
    &'static earlgrey::chip::EarlGrey<
        'static,
        {
            <earlgrey::epmp::EPMPDebugEnable as earlgrey::epmp::EPMPDebugConfig>::TOR_USER_REGIONS
        },
        earlgrey::chip::EarlGreyDefaultPeripherals<
            'static,
            ChipConfig,
            crate::pinmux_layout::BoardPinmuxLayout,
        >,
        ChipConfig,
        crate::pinmux_layout::BoardPinmuxLayout,
        earlgrey::epmp::EarlGreyEPMP<
            { EPMP_HANDOVER_CONFIG_CHECK },
            earlgrey::epmp::EPMPDebugEnable,
        >,
    >,
> = None;
#[no_mangle]
#[link_section = ".stack_buffer"]
pub static mut STACK_MEMORY: [u8; 2304usize] = [0; 2304usize];
extern "C" {
    /// Beginning of the ROM region containing app images.
    static _sapps: u8;
    /// End of the ROM region containing app images.
    static _eapps: u8;
    /// Beginning of the RAM region for app memory.
    static mut _sappmem: u8;
    /// End of the RAM region for app memory.
    static _eappmem: u8;
    /// The start of the kernel text (Included only for kernel PMP)
    static _stext: u8;
    /// The end of the kernel text (Included only for kernel PMP)
    static _etext: u8;
    /// The start of the kernel / app / storage flash (Included only for kernel PMP)
    static _sflash: u8;
    /// The end of the kernel / app / storage flash (Included only for kernel PMP)
    static _eflash: u8;
    /// The start of the kernel / app RAM (Included only for kernel PMP)
    static _ssram: u8;
    /// The end of the kernel / app RAM (Included only for kernel PMP)
    static _esram: u8;
    /// The start of the OpenTitan manifest
    static _manifest: u8;
}
const FLASH_TESTS_ENABLED: bool = false;
fn get_flash_default_memory_protection_region() -> earlgrey::flash_ctrl::DefaultMemoryProtectionRegion {
    earlgrey::flash_ctrl::DefaultMemoryProtectionRegion::new()
}
fn get_flash_memory_protection_configuration() -> earlgrey::flash_ctrl::MemoryProtectionConfiguration {
    let flash_default_memory_protection_region = get_flash_default_memory_protection_region();
    if FLASH_TESTS_ENABLED {
        let page_index_range = earlgrey::flash_ctrl::tests::convert_flash_slice_to_page_position_range(unsafe {
                core::slice::from_raw_parts(
                    &_sapps as *const u8,
                    &_eapps as *const u8 as usize - &_sapps as *const u8 as usize,
                )
            })
            .unwrap();
        use earlgrey::flash_ctrl::DataMemoryProtectionRegionBase;
        use earlgrey::flash_ctrl::DataMemoryProtectionRegionSize;
        let memory_protection_page0_base = DataMemoryProtectionRegionBase::new(
            *page_index_range.end(),
        );
        const RAW_MEMORY_PROTECTION_PAGE0_SIZE: core::num::NonZeroU16 = match core::num::NonZeroU16::new(
            1,
        ) {
            Some(non_zero_u16) => non_zero_u16,
            None => unreachable!(),
        };
        const MEMORY_PROTECTION_PAGE0_SIZE: DataMemoryProtectionRegionSize = match DataMemoryProtectionRegionSize::new(
            RAW_MEMORY_PROTECTION_PAGE0_SIZE,
        ) {
            Ok(memory_protection_page0_size) => memory_protection_page0_size,
            Err(()) => unreachable!(),
        };
        earlgrey::flash_ctrl::MemoryProtectionConfiguration::new(
                flash_default_memory_protection_region,
            )
            .enable_and_configure_data_region(
                earlgrey::flash_ctrl::DataMemoryProtectionRegionIndex::Index0,
                memory_protection_page0_base,
                MEMORY_PROTECTION_PAGE0_SIZE,
            )
            .enable_erase()
            .enable_write()
            .enable_read()
            .enable_high_endurance()
            .finalize_region()
            .enable_and_configure_info2_region(
                earlgrey::flash_ctrl::tests::VALID_INFO2_MEMORY_PROTECTION_REGION_INDEX,
            )
            .enable_erase()
            .enable_write()
            .enable_read()
            .enable_high_endurance()
            .finalize_region()
    } else {
        let starting_address = earlgrey::flash_ctrl::FlashAddress::new_from_host_address(unsafe {
                &_stext as *const u8
            })
            .unwrap();
        let ending_address = earlgrey::flash_ctrl::FlashAddress::new_from_host_address(unsafe {
                &_etext as *const u8
            })
            .unwrap();
        earlgrey::flash_ctrl::MemoryProtectionConfiguration::new(
                flash_default_memory_protection_region,
            )
            .enable_and_configure_data_region_from_pointers(
                earlgrey::flash_ctrl::DataMemoryProtectionRegionIndex::Index0,
                starting_address,
                ending_address,
            )
            .unwrap()
            .enable_read()
            .finalize_region()
            .enable_and_configure_info2_region(
                earlgrey::flash_ctrl::Info2MemoryProtectionRegionIndex::Bank1(
                    earlgrey::flash_ctrl::Info2PageIndex::Index1,
                ),
            )
            .enable_read()
            .enable_write()
            .enable_erase()
            .finalize_region()
    }
}
struct EarlGrey {
    lldb21b59893_62c3_405c_aa3f_a8c34fa3cc0d: &'static capsules_core::low_level_debug::LowLevelDebug<
        'static,
        capsules_core::virtualizers::virtual_uart::UartDevice<'static>,
    >,
    console1ea1d6f0_9541_4be1_85d8_4f577cd7a562: &'static capsules_core::console::Console<
        'static,
    >,
    schedulerc7f66d07_fc87_4ee9_84f6_1951476316eb: &'static kernel::scheduler::cooperative::CooperativeSched<
        'static,
    >,
    scheduler_timer: &'static (),
}
impl SyscallDriverLookup for EarlGrey {
    fn with_driver<F, R>(&self, driver_num: usize, f: F) -> R
    where
        F: FnOnce(Option<&dyn kernel::syscall::SyscallDriver>) -> R,
    {
        match driver_num {
            capsules_core::low_level_debug::DRIVER_NUM => {
                f(Some(self.lldb21b59893_62c3_405c_aa3f_a8c34fa3cc0d))
            }
            capsules_core::console::DRIVER_NUM => {
                f(Some(self.console1ea1d6f0_9541_4be1_85d8_4f577cd7a562))
            }
            _ => f(None),
        }
    }
}
impl KernelResources<
    earlgrey::chip::EarlGrey<
        'static,
        {
            <earlgrey::epmp::EPMPDebugEnable as earlgrey::epmp::EPMPDebugConfig>::TOR_USER_REGIONS
        },
        earlgrey::chip::EarlGreyDefaultPeripherals<
            'static,
            ChipConfig,
            crate::pinmux_layout::BoardPinmuxLayout,
        >,
        ChipConfig,
        crate::pinmux_layout::BoardPinmuxLayout,
        earlgrey::epmp::EarlGreyEPMP<
            { EPMP_HANDOVER_CONFIG_CHECK },
            earlgrey::epmp::EPMPDebugEnable,
        >,
    >,
> for EarlGrey {
    type SyscallDriverLookup = Self;
    type SyscallFilter = ();
    type ProcessFault = ();
    type Scheduler = kernel::scheduler::cooperative::CooperativeSched<'static>;
    type SchedulerTimer = ();
    type WatchDog = ();
    type ContextSwitchCallback = ();
    fn syscall_driver_lookup(&self) -> &Self::SyscallDriverLookup {
        self
    }
    fn syscall_filter(&self) -> &Self::SyscallFilter {
        &()
    }
    fn process_fault(&self) -> &Self::ProcessFault {
        &()
    }
    fn scheduler(&self) -> &Self::Scheduler {
        &self.schedulerc7f66d07_fc87_4ee9_84f6_1951476316eb
    }
    fn scheduler_timer(&self) -> &Self::SchedulerTimer {
        &self.scheduler_timer
    }
    fn watchdog(&self) -> &Self::WatchDog {
        &()
    }
    fn context_switch_callback(&self) -> &Self::ContextSwitchCallback {
        &()
    }
}
unsafe fn setup() -> (
    &'static kernel::Kernel,
    EarlGrey,
    &'static earlgrey::chip::EarlGrey<
        'static,
        {
            <earlgrey::epmp::EPMPDebugEnable as earlgrey::epmp::EPMPDebugConfig>::TOR_USER_REGIONS
        },
        earlgrey::chip::EarlGreyDefaultPeripherals<
            'static,
            ChipConfig,
            crate::pinmux_layout::BoardPinmuxLayout,
        >,
        ChipConfig,
        crate::pinmux_layout::BoardPinmuxLayout,
        earlgrey::epmp::EarlGreyEPMP<
            { EPMP_HANDOVER_CONFIG_CHECK },
            earlgrey::epmp::EPMPDebugEnable,
        >,
    >,
) {
    let memory_allocation_cap = kernel::create_capability!(
        kernel::capabilities::MemoryAllocationCapability
    );
    let board_kernel = kernel::static_init!(
        kernel::Kernel, kernel::Kernel::new(& * core::ptr::addr_of!(PROCESSES))
    );
    let earlgrey_epmp = earlgrey::epmp::EarlGreyEPMP::new_debug(
            earlgrey::epmp::FlashRegion(
                rv32i::pmp::NAPOTRegionSpec::new(
                        core::ptr::addr_of!(_sflash),
                        core::ptr::addr_of!(_eflash) as usize
                            - core::ptr::addr_of!(_sflash) as usize,
                    )
                    .unwrap(),
            ),
            earlgrey::epmp::RAMRegion(
                rv32i::pmp::NAPOTRegionSpec::new(
                        core::ptr::addr_of!(_ssram),
                        core::ptr::addr_of!(_esram) as usize
                            - core::ptr::addr_of!(_ssram) as usize,
                    )
                    .unwrap(),
            ),
            earlgrey::epmp::MMIORegion(
                rv32i::pmp::NAPOTRegionSpec::new(0x40000000 as *const u8, 0x10000000)
                    .unwrap(),
            ),
            earlgrey::epmp::KernelTextRegion(
                rv32i::pmp::TORRegionSpec::new(
                        core::ptr::addr_of!(_stext),
                        core::ptr::addr_of!(_etext),
                    )
                    .unwrap(),
            ),
            earlgrey::epmp::RVDMRegion(
                rv32i::pmp::NAPOTRegionSpec::new(0x00010000 as *const u8, 0x00001000)
                    .unwrap(),
            ),
        )
        .unwrap();
    let flash_memory_protection_configuration = get_flash_memory_protection_configuration();
    let peripherals = kernel::static_init!(
        earlgrey::chip::EarlGreyDefaultPeripherals < ChipConfig, crate
        ::pinmux_layout::BoardPinmuxLayout >,
        earlgrey::chip::EarlGreyDefaultPeripherals::new(flash_memory_protection_configuration)
    );
    let chip = kernel::static_init!(
        earlgrey::chip::EarlGrey < 'static, { < earlgrey::epmp::EPMPDebugEnable as
        earlgrey::epmp::EPMPDebugConfig > ::TOR_USER_REGIONS },
        earlgrey::chip::EarlGreyDefaultPeripherals < 'static, ChipConfig, crate
        ::pinmux_layout::BoardPinmuxLayout >, ChipConfig, crate
        ::pinmux_layout::BoardPinmuxLayout, earlgrey::epmp::EarlGreyEPMP < {
        EPMP_HANDOVER_CONFIG_CHECK }, earlgrey::epmp::EPMPDebugEnable >, >,
        earlgrey::chip::EarlGrey::new(peripherals, earlgrey_epmp),
    );
    let mux_uart0f404613_91e0_4775_a2c3_8b7ef820f894 = {
        components::console::UartMuxComponent::new(&peripherals.uart0, 115200u32)
            .finalize(components::uart_mux_component_static!())
    };
    let lldb21b59893_62c3_405c_aa3f_a8c34fa3cc0d = components::lldb::LowLevelDebugComponent::new(
            board_kernel,
            capsules_core::low_level_debug::DRIVER_NUM,
            mux_uart0f404613_91e0_4775_a2c3_8b7ef820f894,
        )
        .finalize(components::low_level_debug_component_static!());
    let console1ea1d6f0_9541_4be1_85d8_4f577cd7a562 = components::console::ConsoleComponent::new(
            board_kernel,
            capsules_core::console::DRIVER_NUM,
            mux_uart0f404613_91e0_4775_a2c3_8b7ef820f894,
        )
        .finalize(components::console_component_static!());
    let schedulerc7f66d07_fc87_4ee9_84f6_1951476316eb = components::sched::cooperative::CooperativeComponent::new(
            &*core::ptr::addr_of!(PROCESSES),
        )
        .finalize(components::cooperative_component_static!(NUM_PROCS));
    let platform939fe875_c46a_4258_a831_a2a06e61dc74 = EarlGrey {
        lldb21b59893_62c3_405c_aa3f_a8c34fa3cc0d,
        console1ea1d6f0_9541_4be1_85d8_4f577cd7a562,
        schedulerc7f66d07_fc87_4ee9_84f6_1951476316eb,
        scheduler_timer: &(),
    };
    let __process_management_capability = kernel::create_capability!(
        kernel::capabilities::ProcessManagementCapability
    );
    extern "C" {
        static _sapps: u8;
        static _eapps: u8;
        static mut _sappmem: u8;
        static _eappmem: u8;
    }
    kernel::process::load_processes(
            board_kernel,
            chip,
            core::slice::from_raw_parts(
                core::ptr::addr_of!(_sapps),
                core::ptr::addr_of!(_eapps) as usize
                    - core::ptr::addr_of!(_sapps) as usize,
            ),
            core::slice::from_raw_parts_mut(
                core::ptr::addr_of_mut!(_sappmem),
                core::ptr::addr_of!(_eappmem) as usize
                    - core::ptr::addr_of!(_sappmem) as usize,
            ),
            &mut *core::ptr::addr_of_mut!(PROCESSES),
            &FAULT_RESPONSE,
            &__process_management_capability,
        )
        .unwrap_or_else(|err| {
            kernel::debug!("Error loading processes!");
            kernel::debug!("{:?}", err);
        });
    (board_kernel, platform939fe875_c46a_4258_a831_a2a06e61dc74, chip)
}
#[no_mangle]
pub unsafe fn main() {
    let __main_loop_capability = kernel::create_capability!(
        kernel::capabilities::MainLoopCapability
    );
    let (board_kernel, platform, chip) = setup();
    board_kernel
        .kernel_loop(
            &platform,
            chip,
            None::<&kernel::ipc::IPC<0>>,
            &__main_loop_capability,
        );
}
